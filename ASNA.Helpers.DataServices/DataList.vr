Using System
Using System.Collections
Using System.Collections.Generic
Using System.Text
Using System.Text.RegularExpressions
Using System.Data 
Using System.Diagnostics
Using System.IO 
using ASNA.DataGate.Client
using ASNA.DataGate.Common
Using ASNA.DataGate.DataLink
Using ASNA.DataGate.Providers
Using System.ComponentModel
Using System.Diagnostics
Using NewtonSoft.Json

DclNameSpace ASNA.Helpers.DataServices

BegClass DataList Access(*Public) 
    DclFld DGDB     Type(AdgConnection) 
    DclFld DGFile   Type(FileAdapter)     
    DclFld DGDS     Type(AdgDataSet)
    DclFld Library  Type(*String) 
    DclFld File     Type(*String) 
    DclFld Rows     Type(*Integer4)

    DclArray Fields Type(*String) Rank(1) Access(*Private)
    
    DclFld FileKeys Type(List(*Of FileKey)) Access(*Private) New()
    DclFld DGDB  Type(AdgConnection) Access(*Private)   
    
    DclFld _ErrorException Type(System.Exception) 
    BegProp ErrorException Type(System.Exception) Access(*Public)
        BegGet
            LeaveSr _ErrorException
        EndGet
    EndProp

    DclFld _IndentJson Type(*Boolean) 
    BegProp IndentJson Type(*Boolean) Access(*Public) 
        BegSet
            _IndentJson = *PropVal
        EndSet
    EndProp

    DclFld _Query Type(*String) 
    BegProp Query Type(*String) Access(*Public)
        BegSet
            *This._Query = *PropVal 
        EndSet
    EndProp 

    DclFld _ListAsDataTable Type(DataTable) 
    BegProp ListAsDataTable Type(DataTable) Access(*Public) 
        BegGet 
            LeaveSr *This._ListAsDataTable
        EndGet 
    EndProp 

    DclFld _ListAsJson Type(*String)
    BegProp ListAsJson Type(*String) Access(*Public)
        BegGet
            LeaveSr *This._ListAsJson
        EndGet
    EndProp

    DclFld GenerateJsonDataList Type(*Boolean) Inz(*True) Access(*Public)
    DclFld ResultRowCount       Type(*Integer4) Access(*Public) 
    DclFld Milliseconds         Type(*Integer4) Access(*Public)
    DclFld StartingKeys         Type(List(*Of FileKey)) Access(*Public) New()
    DclFld EndingKeys           Type(List(*Of FileKey)) Access(*Public) New()  
    
//    BegConstructor  Access(*Public) 
//        // Instance with individual arguments.
//        DclSrParm DGDB           Type(AdgConnection)
//        DclSrParm Library        Type(*String) 
//        DclSrParm File           Type(*String) 
//        DclSrParm Fields         Type(*String) 
//        DclSrParm Rows           Type(*Integer4)
//
//        *This.DGDB = DGDB
//        *This.Library = Library
//        *This.File = File
//        SetFieldsArray(Fields)
//        *This.Rows = Rows
//
//        // If you instance this object this way, in the consuming code you need to immediately
//        // use its AddKey method to add key fields and values and you need to set the Query property.
//
//        // DGList = *New ASNA.Helpers.DataServices.DataList(db,"examples","mylib","STATE,COUNTY",-1) 
//        // DGList.AddKey("CMNAME","Smi")
//        // DGList.AddKey("CMCUSTNO","30000")
//        // DGList.Query = "CMNAME >= '{CMNAME}' AND CMCUSTNO >= {CMCUSTNO}" 
//
//        // One of the following constructors is probably better than this one for most cases. 
//    EndConstructor 

//    BegConstructor Access(*Public) //This(DGDB,args)
//        // Instance with Json.
//        DclSrParm DGDB   Type(AdgConnection)
//        DclSrParm Json   Type(*String) 
//
//        DclFld args Type(DataListInstanceArgs)
//
//        timer.Start()
//
//        DclFld sw1 Type(Stopwatch) New()
//
//        sw1.Start()
//        args = *New DataListInstanceArgs()
//        args = JsonConvert.DeserializeObject(json, args.GetType()) *As DataListInstanceArgs
//        sw1.Stop()
//
//        *This.DGDB = DGDB
//        *This.Library = args.library
//        *This.File = args.file
//        SetFieldsArray(args.fields)
//        *This.Rows = args.rows
//        *This._Query = args.query
//        SetKeyFields(args.keys)
//    EndConstructor 

    BegConstructor Access(*Public) 
        // Instance with DataListInstanceArgs object.
        DclSrParm DGDB   Type(AdgConnection)
        DclSrParm Args   Type(DataListInstanceArgs) 

        *This.DGDB = DGDB
        *This.Library = args.library
        *This.File = args.file
        SetFieldsArray(args.fields)
        *This.Rows = args.rows
        *This._Query = args.query
        SetKeyFields(args.keys)
    EndConstructor 

    BegSr SetFieldsArray 
        DclSrParm FieldsString Type(*String) 

        *This.Fields = Regex.Split(FieldsString.Trim(), "\s*,\s*") 
    EndSr

    BegSr SetKeyFields
        DclSrParm Keys Type(List(*Of FileKey)) 

        ForEach fk Type(FileKey) Collection(Keys) 
            *This.AddKey(fk.FieldName, fk.FieldValue) 
        EndFor 
    EndSr
     
    BegFunc OpenForDataSetForRead Access(*Private) Type(*Boolean) 
        DGFile = *New FileAdapter(DGDB,String.Format("{0}/{1}",Library.Trim(),File.Trim()))
        DGFile.OpenAttributes.BlockingFactor = FileOpenAttr.OptimalBlockingFactor
        DGFile.AccessMode = AccessMode.Read
        LeaveSr *True 
    EndFunc   

    BegFunc GetKeyTable Type(AdgKeyTable) 
        DclSrParm DGFile Type(FileAdapter) 

        DclFld FormatName Type(*String) 
        DclFld Result Type(AdgKeyTable) 
        
        FormatName = DGFile.GetFormatName(0)      
        Result = DGDS.NewKeyTable(FormatName) 
        
        LeaveSr Result         
    EndFunc 
    
    BegSr AddKey Access(*Public) 
        DclSrParm KeyField  Type(*String) 
        DclSrParm KeyValue Type(*Object) 
        
        FileKeys.Add(*New FileKey(KeyField, KeyValue))       
    EndSr
       
    BegFunc GetRowsAsDataTable Access(*Public) Type(DataTable) 
        DclSrParm RecordsToRead Type(*Integer4) 
       
        *This.OpenForDataSetForRead()       
        ReadRows(RecordsToRead) 

        DGFile.Close()

        LeaveSr DGDS.Tables[0]
    EndFunc 

    BegSr ReadRows
        DclSrParm RecordsToRead Type(*Integer4) 

        DclFld EOF           Type(*Boolean)
        DclFld QueryMask     Type(StringBuilder) New()
        DclFld Query         Type(*String) 
        DclFld Counter       Type(*Integer4)
        
        DclArray Keys        Type(*String) Rank(1)
        DclArray Usage       Type(ASNA.DataGate.Common.KeyUsages) Rank(1)

        QueryMask.Append(CheckQueryArgs(*This._Query.ToUpper())) 
        CreateQueryDefinition(QueryMask)                 
        SetCorrectAndOrInQuery(QueryMask)
        PopulateDGKeysAndUsage(*ByRef Keys,*ByRef Usage)
        
        Query = QueryMask.ToString() 

        EOF = *False    
        Counter = 0 
        DGFile.OpenSimpleQuery(*ByRef DGDS,"*UNIQUE",Query,Keys,Usage)
        DoWhile NOT ReadNextRecord(DGFile)
            Counter += 1 
            If (Counter = RecordsToRead)
                Leave
            EndIf
        EndDo 
    EndSr

    BegFunc ReadNextRecord Type(*Boolean) 
        DclSrParm DGFile Type(FileAdapter) 
        
        Try
            DGFile.ReadSequential(DGDS, ReadSequentialMode.Next, LockRequest.Read)
            LeaveSr *False 
        Catch DgEx Type(dgException) 
            If (DgEx.Error = dgErrorNumber.dgEaEOF)
                LeaveSr *True 
            Else
                Throw DgEx           
            EndIf
        EndTry    
    EndFunc     

    BegFunc CheckQueryArgs Type(*String) 
        DclSrParm Query Type(*String) 

        DclFld Result Type(*String) 

        // Ensure that replacement query args are in the format
        // {arg} with not spaces inside the braces.
        Result = Regex.Replace(Query,"{\s*", "{")
        Result = Regex.Replace(Result,"\s*}", "}")

        LeaveSr Result 
    EndFunc 

    BegSr CreateQueryDefinition
        DclSrParm QueryMask Type(StringBuilder) 

        DclFld KeyField  Type(*String)
        DclFld KeyValue  Type(*String)
        DclFld i         Type(*Integer4)
        
        // Create query for OpenQueryFile.    
        Do FromVal(0) ToVal(FileKeys.Count - 1) Index(i)
            KeyValue = String.Format("{0}", FileKeys[i].FieldValue.ToString()) 
            KeyField = String.Format("{{{0}}}",FileKeys[i].FieldName)
            QueryMask.Replace( KeyField,KeyValue) 
        EndDo
    EndSr

    BegSr PopulateDGKeysAndUsage
        DclSrParm Keys   Type(*String) Rank(1) By(*Reference)
        DclSrParm Usage Type(ASNA.DataGate.Common.KeyUsages) Rank(1) By(*Reference) 

        DclFld i Type(*Integer4)

        Keys = *New String[*This.FileKeys.Count] 
        Usage = *New KeyUsages[*This.FileKeys.Count] 
        Do FromVal(0) ToVal(*This.FileKeys.Count - 1) Index(i)
            keys[i] = *This.FileKeys[i].FieldName
            Usage[i] = KeyUsages.ASCEND
        EndDo     
    EndSr

    BegSr SetCorrectAndOrInQuery
        DclSrParm QueryMask Type(StringBuilder) 

        If (DGDB.SourceProfile.Label.Trim() = "DB2" OR DGDB.SourceProfile.Label.Trim() = "IBM i")  
            // Non-IBM i platforms don't want the asterisk with the AND/OR operations.
            // This code assumes the database name label property isn't "DB2" for non-IBM i databases.
            QueryMask.Replace(" AND "," *AND ") 
            QueryMask.Replace(" OR "," *OR ") 
        EndIf 
    EndSr 

    BegFunc FixApostrophe Type(*String)
        DclSrParm FieldValue Type(*String)
        // OpenQueryFile chokes with embedded single apostrophes. This function
        // swaps any single occurrence of an apostrophe for two apostrophes to solve
        // that problem. Note that this is only changing the argument used OpenQueryFile--
        // the underlying data is kept intact.

        DclFld SINGLE_APOSTROPHE Type( *String ) Inz( "'" )
        DclFld DOUBLE_APOSTROPHE Type( *String ) Inz( "''" )
        
        LeaveSr FieldValue.Replace(SINGLE_APOSTROPHE, DOUBLE_APOSTROPHE)         
    EndFunc

    BegFunc GetFieldNameTokens Type(*String) Rank(1)
        DclSrParm FieldName Type(*String) 

        DclArray tokens    Type(*String) Rank(1) 

        DclArray tokens Type(*String) Rank(1) 

        If (FieldName.Contains(":")) 
            tokens = Regex.Split(FieldName.Trim(), "\s*:\s*")             
        Else
            tokens = *New *String[2]
            tokens[0] = FieldName
            tokens[1] = FieldName
        EndIf

        LeaveSr tokens
    EndFunc

    BegFunc GetList Type(*Boolean) Access(*Public)
        DclFld Result               Type(*Boolean) Inz(*False)
        DclFld dt                   Type(DataTable)
        DclFld sb                   Type(StringBuilder) New()
        DclFLd sw                   Type(StringWriter) New(sb)
        DclFld writer               Type(JsonWriter)
        DclFld timer                Type(StopWatch) New()

        DclFld RealFieldName        Type(*String)
        DclFld FieldNameOUtputAlias Type(*String)
        DclArray FieldNameTokens    Type(*String) Rank(1) 

        timer.Start()

        Try
             dt = *This.GetRowsAsDataTable(*This.Rows) 
            *This._ListAsDataTable = dt
            *This.ResultRowCount = dt.Rows.Count

            writer = *New JsonTextWriter(sw)
            If (_IndentJson)
                writer.Formatting = Formatting.Indented
            Else
                writer.Formatting = Formatting.None
            EndIf
            writer.WriteStartObject()
            writer.WritePropertyName("resultRowCount")
            writer.WriteValue(*This.ResultRowCount)
        
            If (*This.GenerateJsonDataList) 
                writer.WritePropertyName("list")
                writer.WriteStartArray()      
                ForEach dr Type(DataRow) Collection(dt.Rows)
                    writer.WriteStartObject()
                    ForEach field Type(*String) Collection(*This.Fields) 
                        FieldNameTokens = GetFieldNameTokens(field) 
                        RealFieldName = FieldNameTokens[0]
                        FieldNameOutputAlias = FieldNameTokens[1]
                        writer.WritePropertyName(FieldNameOutputAlias)
                        writer.WriteValue(dr[RealFieldName].ToString().Trim()) 
                    EndFor
                    writer.WriteEndObject()
                EndFor 
                writer.WriteEndArray()
            EndIf 

            AddBeginningAndEndKeys(writer *As JsonTextWriter, dt)    

            timer.Stop()
            *This.Milliseconds = timer.ElapsedMilliseconds
            writer.WritePropertyName("milliseconds")
            writer.WriteValue(timer.ElapsedMilliseconds.ToString("#,##0")) 
            writer.Close()
            _ListAsJson = sb.ToString() 
            Result = *True 
        Catch Except Type(System.Exception) 
            *This._ErrorException = Except
        EndTry 

        LeaveSr Result
    EndFunc 

    BegSr AddBeginningAndEndKeys
        DclSrParm writer           Type(JsonTextWriter)
        DclSrParm dt               Type(DataTable)

        DclFld dr                  Type(DataRow)         

        writer.WritePropertyName("startingKey")
        writer.WriteStartArray()      
        dr = dt.Rows[0]         
        ForEach key Type(FileKey) Collection(FileKeys)
            writer.WriteStartObject()
            writer.WritePropertyName(key.FieldName)
            writer.WriteValue(dr[key.FieldName].ToString().Trim()) 
            writer.WriteEndObject() 
            *This.StartingKeys.Add(*New FileKey(key.FieldName, dr[key.FieldName].ToString().Trim())) 
        EndFor
        writer.WriteEndArray()
                
        writer.WritePropertyName("endingKey")
        writer.WriteStartArray()      
        dr = dt.Rows[dt.Rows.Count-1] 
        ForEach key Type(FileKey) Collection(FileKeys)
            writer.WriteStartObject()
            writer.WritePropertyName(key.FieldName)
            writer.WriteValue(dr[key.FieldName].ToString().Trim()) 
            writer.WriteEndObject() 
            *This.EndingKeys.Add(*New FileKey(key.FieldName, dr[key.FieldName].ToString().Trim())) 
        EndFor
        
        writer.WriteEndArray()
    EndSr

EndClass